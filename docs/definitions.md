---
title: Windows 主控台和終端機定義
description: 提供此空間中常用的單字和片語定義，以及與主控台和終端機系統相關的檔集。
author: miniksa
ms.author: miniksa
ms.topic: conceptual
keywords: 主控台、終端機、虛擬終端機、主控台主機、命令列、子系統、定義
ms.prod: console
ms.openlocfilehash: 763421a25d5ecaa2291b68b0370644af152622a9
ms.sourcegitcommit: 463975e71920908a6bff9a6a7291ddf3736652d5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/30/2020
ms.locfileid: "93039591"
---
# <a name="definitions"></a><span data-ttu-id="e8816-104">定義</span><span class="sxs-lookup"><span data-stu-id="e8816-104">Definitions</span></span>

<span data-ttu-id="e8816-105">本檔提供此空間中特定單字和片語的定義，並在整個檔集中當做參考使用。</span><span class="sxs-lookup"><span data-stu-id="e8816-105">This document provides the definitions of specific words and phrases in this space and be used as reference throughout this document set.</span></span>

## <a name="command-line-applications"></a><span data-ttu-id="e8816-106">命令列應用程式</span><span class="sxs-lookup"><span data-stu-id="e8816-106">Command Line Applications</span></span>

<span data-ttu-id="e8816-107">命令列應用程式（有時稱為「主控台應用程式」和/或稱為「用戶端」的主控台子系統）是主要針對文字或字元資訊資料流程運作的程式。</span><span class="sxs-lookup"><span data-stu-id="e8816-107">Command line applications, or sometimes called "console applications" and/or referred to as "clients" of the console subsystem, are programs that operate mainly on a stream of text or character information.</span></span> <span data-ttu-id="e8816-108">它們通常不包含自己的使用者介面專案，而且會將輸出/顯示和輸入/互動角色委派給裝載應用程式。</span><span class="sxs-lookup"><span data-stu-id="e8816-108">They generally contain no user interface elements of their own and delegate both the output/display and the input/interaction roles to a hosting application.</span></span> <span data-ttu-id="e8816-109">命令列應用程式會在其標準輸入控制碼上接收文字資料流程 `STDIN` ，這表示使用者的鍵盤輸入、處理該資訊，然後以標準輸出上的文字資料流程回應， `STDOUT` 以顯示回使用者的監視器。</span><span class="sxs-lookup"><span data-stu-id="e8816-109">Command line applications receive a stream of text on their standard input `STDIN` handle which represents a user's keyboard input, process that information, then respond with a stream of text on their standard output `STDOUT` for display back to the user's monitor.</span></span> <span data-ttu-id="e8816-110">當然，對於其他輸入裝置和遠端案例而言，這會隨著時間而進化，但相同的基本原理仍然相同：命令列用戶端會在文字上操作，而其他人則會管理顯示/輸入。</span><span class="sxs-lookup"><span data-stu-id="e8816-110">Of course, this has evolved over time for additional input devices and remote scenarios, but the same basic philosophy remains the same: command-line clients operate on text and someone else manages display/input.</span></span>

## <a name="standard-handles"></a><span data-ttu-id="e8816-111">標準控制碼</span><span class="sxs-lookup"><span data-stu-id="e8816-111">Standard Handles</span></span>

<span data-ttu-id="e8816-112">標準控點是一系列、 `STDIN` 、 `STDOUT` 和 `STDERR` ，在啟動時導入為進程空間的一部分。</span><span class="sxs-lookup"><span data-stu-id="e8816-112">The standard handles are a series, `STDIN`, `STDOUT`, and `STDERR`, introduced as part of a process space on startup.</span></span> <span data-ttu-id="e8816-113">它們代表在中要接受和送回的資訊位置， (包括將錯誤回報) 的特殊位置。</span><span class="sxs-lookup"><span data-stu-id="e8816-113">They represent a place for information to be accepted on the way in and sent back on the way out (including a special place to report errors out).</span></span> <span data-ttu-id="e8816-114">如果是命令列應用程式，這些應用程式必須一律存在於應用程式啟動時。</span><span class="sxs-lookup"><span data-stu-id="e8816-114">For command-line applications, these must always exist when the application starts.</span></span> <span data-ttu-id="e8816-115">它們會自動從父系繼承、由父系明確設定，或者如果未指定/允許，則由作業系統自動建立。</span><span class="sxs-lookup"><span data-stu-id="e8816-115">They are either inherited from the parent automatically, set explicitly by the parent, or created automatically by the operating system if neither are specified/permitted.</span></span> <span data-ttu-id="e8816-116">若為傳統 Windows 應用程式，這些應用程式在啟動時可能會空白。</span><span class="sxs-lookup"><span data-stu-id="e8816-116">For classic Windows applications, these may be blank on startup.</span></span> <span data-ttu-id="e8816-117">不過，它們可以隱含或明確地繼承自父系，或在執行時間由應用程式本身進行配置、附加和釋放。</span><span class="sxs-lookup"><span data-stu-id="e8816-117">However, they can be implicitly or explicitly inherited from the parent or allocated, attached, and freed during runtime by the application itself.</span></span>

<span data-ttu-id="e8816-118">標準控點不代表特定類型的已連接裝置。</span><span class="sxs-lookup"><span data-stu-id="e8816-118">Standard handles do not imply a specific type of attached device.</span></span> <span data-ttu-id="e8816-119">不過，在命令列應用程式的情況下，裝置最常是主控台裝置、shell) 中的重新導向 (的檔案，或是從將一個公用程式的輸出連接到下一個) 之輸入的命令介面 (的管道。</span><span class="sxs-lookup"><span data-stu-id="e8816-119">In the case of command-line applications, however, the device is most commonly a console device, file (from redirection in a shell), or a pipe (from a shell connecting the output of one utility to the input of the next).</span></span> <span data-ttu-id="e8816-120">它也可能是通訊端或任何其他類型的裝置。</span><span class="sxs-lookup"><span data-stu-id="e8816-120">It may also be a socket or any other type of device.</span></span>

## <a name="ttypty"></a><span data-ttu-id="e8816-121">TTY/PTY</span><span class="sxs-lookup"><span data-stu-id="e8816-121">TTY/PTY</span></span>

<span data-ttu-id="e8816-122">在非 Windows 平臺上，TTY 和 PTY 裝置分別代表真正的實體裝置或軟體建立的虛擬裝置，與 Windows 主控台會話的概念相同：命令列用戶端應用程式與伺服器主機互動性應用程式之間通訊的通道，或實體鍵盤/顯示裝置可以交換以文字為基礎的資訊。</span><span class="sxs-lookup"><span data-stu-id="e8816-122">On non-Windows platforms, the TTY and PTY devices represent respectively either a true physical device or a software-created pseudo-device that are the same concept as a Windows console session: a channel where communication between a command-line client application and a server host interactivity application or physical keyboard/display device can exchange text-based information.</span></span>

## <a name="clients-and-servers"></a><span data-ttu-id="e8816-123">用戶端和伺服器</span><span class="sxs-lookup"><span data-stu-id="e8816-123">Clients and Servers</span></span>

<span data-ttu-id="e8816-124">在此空間中，我們將「用戶端」視為可執行處理資訊和執行命令之工作的應用程式。</span><span class="sxs-lookup"><span data-stu-id="e8816-124">Within this space, we're referring to "clients" as applications that do the work of processing information and running commands.</span></span> <span data-ttu-id="e8816-125">「伺服器」應用程式是負責使用者介面的應用程式，而且是背景工作角色，代表用戶端將輸入和輸出轉譯成標準格式。</span><span class="sxs-lookup"><span data-stu-id="e8816-125">The "server" applications are those that are responsible for the user interface and are workers to translate input and output into standard forms on behalf of the clients.</span></span>

## <a name="console-subsystem"></a><span data-ttu-id="e8816-126">主控台子系統</span><span class="sxs-lookup"><span data-stu-id="e8816-126">Console Subsystem</span></span>

<span data-ttu-id="e8816-127">這是一個全面的詞彙，代表影響主控台和命令列操作的所有模組。</span><span class="sxs-lookup"><span data-stu-id="e8816-127">This is a catch-all term representing all modules affecting console and command-line operations.</span></span> <span data-ttu-id="e8816-128">它特別指的是可攜式可執行檔標頭一部分的旗標，此旗標會指定啟動應用程式是否 (命令列/主控台應用程式，而且必須具有啟動) 或 windows 應用程式 (的標準控制碼，而且不需要) 。</span><span class="sxs-lookup"><span data-stu-id="e8816-128">It specifically refers to a flag that is a part of the Portable Executable header that specifies whether the starting application is either a command-line/console application (and must have standard handles to start) or a windows application (and does not need them).</span></span>

<span data-ttu-id="e8816-129">主控台主機、命令列用戶端應用程式、主控台驅動程式、主控台 API 介面、pseudoconsole 基礎結構、終端機、設定屬性工作表、進程載入器內的機制和存根，以及與這些形式的應用程式運作相關的任何公用程式都會被視為屬於此群組。</span><span class="sxs-lookup"><span data-stu-id="e8816-129">The console host, command-line client applications, the console driver, the console API surface, the pseudoconsole infrastructure, terminals, configuration property sheets, the mechanisms and stubs inside the process loader, and any utilities related to the workings of these forms of applications are considered to belong to this group.</span></span>

## <a name="console-host"></a><span data-ttu-id="e8816-130">主控台主機</span><span class="sxs-lookup"><span data-stu-id="e8816-130">Console Host</span></span>

<span data-ttu-id="e8816-131">Windows 主控台主機或都 `conhost.exe` 是適用于所有 Windows 主控台 api 的伺服器應用程式，以及使用命令列應用程式的傳統 Windows 使用者介面。</span><span class="sxs-lookup"><span data-stu-id="e8816-131">The Windows Console Host, or `conhost.exe`, is both the server application for all of the Windows Console APIs as well as the classic Windows user interface for working with command-line applications.</span></span> <span data-ttu-id="e8816-132">此二進位檔的完整內容（即 API 伺服器和 UI）在過去屬於 Windows `csrss.exe` 、重要的系統進程，而且基於安全性和隔離的目的而分歧。</span><span class="sxs-lookup"><span data-stu-id="e8816-132">The complete contents of this binary, both the API server and the UI, historically belonged to Windows `csrss.exe`, a critical system process, and was diverged for security and isolation purposes.</span></span> <span data-ttu-id="e8816-133">未來， `conhost.exe` 將會繼續負責進行 API 呼叫服務和轉譯，但使用者介面元件的目的是要透過 pseudoconsole 將其委派給終端機。</span><span class="sxs-lookup"><span data-stu-id="e8816-133">Going forward, `conhost.exe` will continue to be responsible for API call servicing and translation, but the user-interface components are intended to be delegated through a pseudoconsole to a terminal.</span></span>

## <a name="pseudoconsole"></a><span data-ttu-id="e8816-134">Pseudoconsole</span><span class="sxs-lookup"><span data-stu-id="e8816-134">Pseudoconsole</span></span>

<span data-ttu-id="e8816-135">這是從其他平臺 pseudoterminal 或「PTY」的 Windows 模擬。</span><span class="sxs-lookup"><span data-stu-id="e8816-135">This is the Windows simulation of a pseudoterminal or "PTY" from other platforms.</span></span> <span data-ttu-id="e8816-136">它會嘗試比對 PTYs 的一般介面原理，提供簡單的雙向通道來進行文字通訊，但它會在具有大型相容性層的 Windows 上進行補充，以將此設計原理之前所撰寫的 Windows 應用程式，從傳統主控台 API 介面變更為簡單的文字通道通訊形式。</span><span class="sxs-lookup"><span data-stu-id="e8816-136">It tries to match the general interface philosophy of PTYs, providing a simple bidirectional channel of text based communication, but it supplements it on Windows with a large compatibility layer to translate the breadth of Windows applications written prior to this design philosophy change from the classic console API surface into the simple text channel communication form.</span></span> <span data-ttu-id="e8816-137">終端機可以使用 pseudoconsole 從主控台主機取得使用者介面元素的擁有權， `conhost.exe` 同時讓它負責 API 服務、轉譯和相容性工作。</span><span class="sxs-lookup"><span data-stu-id="e8816-137">Terminals can use the pseudoconsole to take ownership of the user-interface elements away from the console host, `conhost.exe`, while leaving it in charge of the API servicing, translation, and compatibility efforts.</span></span>

## <a name="terminal"></a><span data-ttu-id="e8816-138">終端</span><span class="sxs-lookup"><span data-stu-id="e8816-138">Terminal</span></span>

<span data-ttu-id="e8816-139">終端機是命令列應用程式的使用者介面和互動模組。</span><span class="sxs-lookup"><span data-stu-id="e8816-139">A terminal is the user-interface and interaction module for a command-line application.</span></span> <span data-ttu-id="e8816-140">現在，它是一種軟體，用來表示在具有顯示器監視器、鍵盤和雙向序列通道的實體裝置之前的用途。</span><span class="sxs-lookup"><span data-stu-id="e8816-140">Today, it's a software representation of what used to be historically a physical device with a display monitor, a keyboard, and a bidirectional serial communication channel.</span></span> <span data-ttu-id="e8816-141">它負責以各種形式來收集使用者的輸入、將它轉譯和編碼，以及將任何特殊的命令資訊轉譯成單一文字資料流程，並將其提交至 PTY，以在 `STDIN` 命令列用戶端應用程式的通道上傳輸。</span><span class="sxs-lookup"><span data-stu-id="e8816-141">It is responsible for gathering input from the user in a variety of forms, translating it and encoding it and any special command information into a single text stream, and submitting it to the PTY for transmission on to the `STDIN` channel of the command-line client application.</span></span> <span data-ttu-id="e8816-142">它也負責透過 PTY 接收來自用戶端應用程式通道的資訊，將 `STDOUT` 任何特殊資訊解碼、配置所有文字和其他命令，並以圖形方式呈現給使用者。</span><span class="sxs-lookup"><span data-stu-id="e8816-142">It is also responsible for receiving back information, via the PTY, that came from a client application's `STDOUT` channel, decoding any special information in the payload, laying out all the text and additional commands, and presenting that graphically to the end user.</span></span>
