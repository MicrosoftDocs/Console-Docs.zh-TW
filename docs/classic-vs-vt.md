---
title: 傳統主控台 Api 與虛擬終端機序列
description: 描述傳統 Win32 主控台 API 介面和虛擬終端機序列（有時也稱為 escape 序列）之間的對比，以撰寫命令列應用程式。
author: miniksa
ms.author: miniksa
ms.topic: conceptual
keywords: 主控台、終端機、虛擬終端機、escape 序列、vt、vt100、主控台 api
ms.prod: console
ms.openlocfilehash: 0fdd39cab5b8f6ca5cc1602c8e68ec7f2a2303ad
ms.sourcegitcommit: 463975e71920908a6bff9a6a7291ddf3736652d5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/30/2020
ms.locfileid: "93039578"
---
# <a name="classic-console-apis-versus-virtual-terminal-sequences"></a><span data-ttu-id="58b4c-104">傳統主控台 Api 與虛擬終端機序列</span><span class="sxs-lookup"><span data-stu-id="58b4c-104">Classic Console APIs versus Virtual Terminal Sequences</span></span>

<span data-ttu-id="58b4c-105">我們的建議是將傳統 **Windows 主控台 API** 取代為 **虛擬終端機序列** 。</span><span class="sxs-lookup"><span data-stu-id="58b4c-105">Our recommendation is to replace the classic **Windows Console API** with **virtual terminal sequences** .</span></span> <span data-ttu-id="58b4c-106">本文將概述兩者之間的差異，並討論建議的原因。</span><span class="sxs-lookup"><span data-stu-id="58b4c-106">This article will outline the difference between the two and discuss the reasons for our recommendation.</span></span>

## <a name="definitions"></a><span data-ttu-id="58b4c-107">定義</span><span class="sxs-lookup"><span data-stu-id="58b4c-107">Definitions</span></span>

<span data-ttu-id="58b4c-108">傳統 **[Windows 主控台 API](console-functions.md)** 介面定義為 `kernel32.dll` 名稱中具有 "Console" 的 C 語言功能介面系列。</span><span class="sxs-lookup"><span data-stu-id="58b4c-108">The classic **[Windows Console API](console-functions.md)** surface is defined as the series of C language functional interfaces on `kernel32.dll` with "Console" in the name.</span></span>

<span data-ttu-id="58b4c-109">**[虛擬終端機序列](console-virtual-terminal-sequences.md)** 定義為內嵌在標準輸入和標準輸出資料流程中的命令語言。</span><span class="sxs-lookup"><span data-stu-id="58b4c-109">**[Virtual terminal sequences](console-virtual-terminal-sequences.md)** is defined as a language of commands that's embedded in the standard input and standard output streams.</span></span> <span data-ttu-id="58b4c-110">虛擬終端機序列使用不可列印的 escape 字元，以使用正常可列印文字來進行交叉信號的命令。</span><span class="sxs-lookup"><span data-stu-id="58b4c-110">Virtual terminal sequences use non-printable escape characters for signaling commands interleaved with normal printable text.</span></span>

## <a name="history"></a><span data-ttu-id="58b4c-111">歷程記錄</span><span class="sxs-lookup"><span data-stu-id="58b4c-111">History</span></span>

<span data-ttu-id="58b4c-112">**Windows 主控台** 針對用戶端命令列應用程式提供廣泛的 API 介面，以操作輸出顯示緩衝區和使用者輸入緩衝區。</span><span class="sxs-lookup"><span data-stu-id="58b4c-112">The **Windows Console** provides a broad API surface for client command-line applications to manipulate both the output display buffer and the user input buffer.</span></span> <span data-ttu-id="58b4c-113">不過，其他非 Windows 平臺從未對其命令列環境將這個特定的 API 導向方法，改為使用內嵌在標準輸入和標準輸出串流內的虛擬終端機序列。</span><span class="sxs-lookup"><span data-stu-id="58b4c-113">However, other non-Windows platforms have never afforded this specific API-driven approach to their command-line environments, choosing instead to use virtual terminal sequences embedded within the standard input and standard output streams.</span></span> <span data-ttu-id="58b4c-114">*(一段時間，Microsoft 會透過稱為 ANSI.SYS 的驅動程式，在舊版 DOS 和 Windows 中支援此行為。 )*</span><span class="sxs-lookup"><span data-stu-id="58b4c-114">*(For a time, Microsoft supported this behavior too in early editions of DOS and Windows through a driver called ANSI.SYS.)*</span></span>

<span data-ttu-id="58b4c-115">相較之下， **虛擬終端機序列** (于各種方言中，) 為所有其他平臺的命令列環境作業驅動。</span><span class="sxs-lookup"><span data-stu-id="58b4c-115">By contrast, **virtual terminal sequences** (in a variety of dialects) drive the command-line environment operations for  all other platforms.</span></span> <span data-ttu-id="58b4c-116">這些序列是以 [ECMA 標準](https://www.ecma-international.org/publications/standards/Ecma-048.htm) 和一系列的延伸模組為基礎，由許多廠商向數位設備公司和 Tektronix 終端機，再到更新式和常見的軟體終端，例如 [xterm](https://invisible-island.net/xterm/)。</span><span class="sxs-lookup"><span data-stu-id="58b4c-116">These sequences are rooted in an [ECMA Standard](https://www.ecma-international.org/publications/standards/Ecma-048.htm) and series of extensions by many vendors tracing back to Digital Equipment Corporation and Tektronix terminals, through to more modern and common software terminals, like [xterm](https://invisible-island.net/xterm/).</span></span> <span data-ttu-id="58b4c-117">虛擬終端機序列網域內有許多擴充功能，而且有些序列比其他序列更廣泛支援，但您可以放心地將其標準化為命令列體驗的命令語言，這是幾乎每個終端機和命令列用戶端應用程式都支援的知名子集。</span><span class="sxs-lookup"><span data-stu-id="58b4c-117">Many extensions exist within the virtual terminal sequence domain and some sequences are more widely supported than others, but it is safe to say that the world has standardized on this as the command language for command-line experiences with a well-known subset being supported by virtually every terminal and command-line client application.</span></span>

## <a name="cross-platform-support"></a><span data-ttu-id="58b4c-118">跨平臺支援</span><span class="sxs-lookup"><span data-stu-id="58b4c-118">Cross-Platform Support</span></span>

<span data-ttu-id="58b4c-119">跨平臺原生支援 **虛擬終端機序列** ，讓終端機應用程式和命令列公用程式輕鬆地在版本和作業系統的變化之間可移植，但 Windows 除外。</span><span class="sxs-lookup"><span data-stu-id="58b4c-119">**Virtual terminal sequences** are natively supported across platforms, making terminal applications and command-line utilities easily portable between versions and variations of operating systems, with the exception of Windows.</span></span>

<span data-ttu-id="58b4c-120">相較之下，windows **主控台 api** 只有在 windows 上才受到支援。</span><span class="sxs-lookup"><span data-stu-id="58b4c-120">By contrast, **Windows Console APIs** are only supported on Windows.</span></span> <span data-ttu-id="58b4c-121">當您嘗試從某個平臺或另一個平臺移植命令列公用程式時，必須在 Windows 與虛擬終端機之間撰寫延伸的介面卡或轉譯程式庫，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="58b4c-121">An extensive adapter or translation library must be written between Windows and virtual terminal, or vice-versa, when attempting to port command-line utilities from one platform or another.</span></span>

### <a name="remote-access"></a><span data-ttu-id="58b4c-122">遠端存取</span><span class="sxs-lookup"><span data-stu-id="58b4c-122">Remote Access</span></span>

<span data-ttu-id="58b4c-123">**虛擬終端機序列** 擁有遠端存取的主要優點。</span><span class="sxs-lookup"><span data-stu-id="58b4c-123">**Virtual terminal sequences** hold a major advantage for remote access.</span></span> <span data-ttu-id="58b4c-124">在設定標準遠端命令列連線所需的設定下，不需要額外的工作來傳輸或執行遠端程序呼叫。</span><span class="sxs-lookup"><span data-stu-id="58b4c-124">They require no additional work to transport, or perform remote procedure calls, over what is required to set up a standard remote command-line connection.</span></span> <span data-ttu-id="58b4c-125">只要將輸出和輸入傳輸通道 (或單一雙向通道) 透過管道、通訊端、檔案、序列埠或任何其他裝置來連接，就足以將應用程式對遠端主機說出這些順序所需的所有資訊全部完整地攜帶起來。</span><span class="sxs-lookup"><span data-stu-id="58b4c-125">Simply connecting an outbound and an inbound transport channel (or a single bidirectional channel) over a pipe, socket, file, serial port, or any other device is sufficient to completely carry all information required for an application speaking these sequences to a remote host.</span></span>

<span data-ttu-id="58b4c-126">相反地， **Windows 主控台 api** 只能在本機電腦上存取，而遠端這些 api 需要建立整個遠端呼叫和傳輸介面層，但只限于簡單的通道。</span><span class="sxs-lookup"><span data-stu-id="58b4c-126">On the contrary, the **Windows Console APIs** have only been accessible on the local machine and all efforts to remote them would require building an entire remote calling and transport interface layer beyond just a simple channel.</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="58b4c-127">關注點分離</span><span class="sxs-lookup"><span data-stu-id="58b4c-127">Separation of Concerns</span></span>

<span data-ttu-id="58b4c-128">某些 **Windows 主控台 api** 提供對輸入和輸出緩衝區的低層級存取，或互動式命令列的便利性函數。</span><span class="sxs-lookup"><span data-stu-id="58b4c-128">Some **Windows Console APIs** provide low-level access to the input and output buffers or convenience functions for interactive command-lines.</span></span> <span data-ttu-id="58b4c-129">這可能包括以程式設計方式在主控台子系統和主機環境內進行程式設計的別名和命令歷程記錄，而不是在命令列用戶端應用程式本身內。</span><span class="sxs-lookup"><span data-stu-id="58b4c-129">This might include aliases and command history programmed within the console subsystem and host environment, instead of within the command-line client application itself.</span></span>

<span data-ttu-id="58b4c-130">相反地， **其他平臺** 則會將應用程式目前狀態的記憶體，和命令列公用程式或 shell 本身的責任提供給便利性功能。</span><span class="sxs-lookup"><span data-stu-id="58b4c-130">By contrast, **other platforms** make memory of the current state of the application and convenience functionality the responsibility of the command-line utility or shell itself.</span></span>

<span data-ttu-id="58b4c-131">在主控台主機和 API 中處理此責任的 **Windows 主控台** 可讓您更快速且更輕鬆地撰寫具有這些功能的命令列應用程式，而不需記住繪製狀態或處理編輯便利性功能的責任。</span><span class="sxs-lookup"><span data-stu-id="58b4c-131">The **Windows Console** way of handling this responsibility in the console host and API makes it quicker and easier to write a command-line application with these features, removing the responsibility of remembering drawing state or handling editing convenience features.</span></span> <span data-ttu-id="58b4c-132">不過，這讓您幾乎無法在不同的平臺、版本或案例之間，從遠端連線這些活動，因為這種方式可讓您在執行和可用性方面有所變化。</span><span class="sxs-lookup"><span data-stu-id="58b4c-132">However, this makes it nearly impossible to connect those activities remotely across platforms, versions, or scenarios due to variations in implementations and availability.</span></span> <span data-ttu-id="58b4c-133">這種處理責任的方式也能讓這些 Windows 命令列應用程式的最終互動式體驗完全相依于主控台主機的執行、優先順序和發行週期。</span><span class="sxs-lookup"><span data-stu-id="58b4c-133">This way of handling responsibility also makes the final interactive experience of these Windows command-line applications completely dependent on the console host's implementation, priorities, and release cycle.</span></span>

<span data-ttu-id="58b4c-134">例如，只有在命令列應用程式自行處理編輯考慮時，才可以使用先進的行編輯功能，例如語法醒目提示和複雜的選取專案。</span><span class="sxs-lookup"><span data-stu-id="58b4c-134">For example, advanced line editing features, like syntax highlighting and complex selection, are only possible when a command-line application handles editing concerns itself.</span></span> <span data-ttu-id="58b4c-135">主控台從來沒有足夠的內容，可以完全瞭解這些案例，就像用戶端應用程式一樣。</span><span class="sxs-lookup"><span data-stu-id="58b4c-135">The console could never have enough context to fully understand these scenarios in a broad manner like the client application can.</span></span>

<span data-ttu-id="58b4c-136">相反地，其他平臺會使用 **虛擬終端機序列** ，透過可重複使用的用戶端程式庫（例如 [readline](https://tiswww.case.edu/php/chet/readline/rltop.html) 和 [ncurses](https://invisible-island.net/ncurses/ncurses.html)）來處理這些活動和虛擬終端機通訊本身。</span><span class="sxs-lookup"><span data-stu-id="58b4c-136">By contrast, other platforms use **virtual terminal sequences** to handle these activities and virtual terminal communication itself through reusable client-side libraries, like [readline](https://tiswww.case.edu/php/chet/readline/rltop.html) and [ncurses](https://invisible-island.net/ncurses/ncurses.html).</span></span> <span data-ttu-id="58b4c-137">最後的終端機會只負責顯示資訊，並透過該雙向通道接收輸入。</span><span class="sxs-lookup"><span data-stu-id="58b4c-137">The final terminal is only responsible for displaying information and receiving input through that bidirectional communication channel.</span></span>

### <a name="wrong-way-verbs"></a><span data-ttu-id="58b4c-138">Wrong-Way 動詞</span><span class="sxs-lookup"><span data-stu-id="58b4c-138">Wrong-Way Verbs</span></span>

<span data-ttu-id="58b4c-139">利用 **Windows 主控台** ，可以在輸入和輸出資料流程上，以相反的自然方向來執行某些動作。</span><span class="sxs-lookup"><span data-stu-id="58b4c-139">With **Windows Console** , some actions can be performed in the opposite-to-natural direction on the input and output streams.</span></span> <span data-ttu-id="58b4c-140">這可讓 Windows 命令列應用程式避免管理自己的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="58b4c-140">This allows Windows command-line applications to avoid the concern of managing their own buffers.</span></span> <span data-ttu-id="58b4c-141">它也可讓 Windows 命令列應用程式執行先進的作業，例如代表使用者模擬/插入輸入，或讀回部分寫入的歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="58b4c-141">It also allows Windows command-line apps to perform advanced operations, like simulating/injecting input on behalf of a user, or reading back some of the history of what was written.</span></span>

<span data-ttu-id="58b4c-142">雖然這可讓 Windows 應用程式在單一電腦上的特定使用者內容中運作，但是在某些情況下使用時，也會提供一種向量來跨安全性和許可權層級或網域。</span><span class="sxs-lookup"><span data-stu-id="58b4c-142">While this provides additional power to Windows applications operating in a specific user-context on a single machine, it also provides a vector to cross security and privilege-levels or domains when used in certain scenarios.</span></span> <span data-ttu-id="58b4c-143">這類案例包括在同一部電腦上的內容之間進行操作，或在不同的內容之間進行作業。</span><span class="sxs-lookup"><span data-stu-id="58b4c-143">Such scenarios include operating between contexts on the same machine, or across contexts to another machine or environment.</span></span>

<span data-ttu-id="58b4c-144">使用 **虛擬終端順序** 的其他平臺不允許此活動。</span><span class="sxs-lookup"><span data-stu-id="58b4c-144">Other platforms, which use **virtual terminal sequences** , do not allow this activity.</span></span> <span data-ttu-id="58b4c-145">從傳統 Windows 主控台轉換至虛擬終端機序列的建議目的是要將此策略與互通性和安全性原因融合在一起。</span><span class="sxs-lookup"><span data-stu-id="58b4c-145">The intent of our recommendation to transition from classic Windows Console to virtual terminal sequences is to converge with this strategy for both interoperability and security reasons.</span></span>

### <a name="direct-window-access"></a><span data-ttu-id="58b4c-146">直接視窗存取</span><span class="sxs-lookup"><span data-stu-id="58b4c-146">Direct Window Access</span></span>

<span data-ttu-id="58b4c-147">**Windows 主控台 API 介面** 可為裝載視窗提供精確的視窗控制碼。</span><span class="sxs-lookup"><span data-stu-id="58b4c-147">**Windows Console API surface** provides the exact window handle to the hosting window.</span></span> <span data-ttu-id="58b4c-148">這可讓命令列公用程式藉由達到視窗控制碼所允許的廣泛 Win32 Api 來執行 advanced window 作業。</span><span class="sxs-lookup"><span data-stu-id="58b4c-148">This allows a command-line utility to perform advanced window operations by reaching into the wide gamut of Win32 APIs permitted against a window handle.</span></span> <span data-ttu-id="58b4c-149">這些 Win32 Api 可以操作視窗狀態、框架、圖示或視窗的其他屬性。</span><span class="sxs-lookup"><span data-stu-id="58b4c-149">These Win32 APIs can manipulate the window state, frame, icon, or other properties about the window.</span></span>

<span data-ttu-id="58b4c-150">相反地，在具有 **虛擬終端順序** 的其他平臺上，會有一組較窄的命令可針對視窗執行。</span><span class="sxs-lookup"><span data-stu-id="58b4c-150">By contrast, on other platforms with **virtual terminal sequences** , there is a narrow set of commands that can be performed against the window.</span></span> <span data-ttu-id="58b4c-151">這些命令可以執行一些動作，例如變更視窗大小或顯示的標題，但必須在相同的頻外完成，並在與資料流程其餘部分相同的控制項下執行。</span><span class="sxs-lookup"><span data-stu-id="58b4c-151">These commands can do things like changing the window size or displayed title, but they must be done in the same band and under the same control as the remainder of the stream.</span></span>

<span data-ttu-id="58b4c-152">隨著 Windows 發展，視窗控制碼的安全性控制和限制也已增加。</span><span class="sxs-lookup"><span data-stu-id="58b4c-152">As Windows has evolved, the security controls and restrictions on window handles have increased.</span></span> <span data-ttu-id="58b4c-153">此外，在任何特定的使用者介面專案上，應用程式可定址的視窗控制碼的本質和存在都已演進，特別是隨著裝置外型規格和平臺的增加支援。</span><span class="sxs-lookup"><span data-stu-id="58b4c-153">Additionally, the nature and existence of an application-addressable window handle on any specific user interface element has evolved, especially with the increased support of device form factors and platforms.</span></span> <span data-ttu-id="58b4c-154">如此一來，當平臺和經驗演進時，直接視窗存取命令列應用程式就會變得脆弱。</span><span class="sxs-lookup"><span data-stu-id="58b4c-154">This makes direct window access to command-line applications fragile as the platform and experiences evolve.</span></span>

### <a name="unicode"></a><span data-ttu-id="58b4c-155">Unicode</span><span class="sxs-lookup"><span data-stu-id="58b4c-155">Unicode</span></span>

<span data-ttu-id="58b4c-156">UTF-8 是幾乎所有新式平臺上的 Unicode 資料所接受的編碼方式，因為它會在可攜性、儲存體大小和處理時間之間取得適當的平衡。</span><span class="sxs-lookup"><span data-stu-id="58b4c-156">UTF-8 is the accepted encoding for Unicode data across almost all modern platforms, as it strikes the right balance between portability, storage size and processing time.</span></span> <span data-ttu-id="58b4c-157">不過，Windows 過去選擇 UTF-16 作為 Unicode 資料的主要編碼方式。</span><span class="sxs-lookup"><span data-stu-id="58b4c-157">However, Windows historically chose UTF-16 as its primary encoding for Unicode data.</span></span> <span data-ttu-id="58b4c-158">UTF-8 的支援會在 Windows 中增加，使用這些 Unicode 格式並不會妨礙其他編碼的使用。</span><span class="sxs-lookup"><span data-stu-id="58b4c-158">Support for UTF-8 is increasing in Windows and use of these Unicode formats does not preclude the usage of other encodings.</span></span>

<span data-ttu-id="58b4c-159">**Windows 主控台** 平臺已受到支援，並將繼續支援所有現有的字碼頁和編碼。</span><span class="sxs-lookup"><span data-stu-id="58b4c-159">The **Windows Console** platform has supported and will continue to support all existing code pages and encodings.</span></span> <span data-ttu-id="58b4c-160">使用 UTF-16 以取得跨 Windows 版本的最大相容性，並視需要使用 UTF-8 執行演算法轉譯。</span><span class="sxs-lookup"><span data-stu-id="58b4c-160">Use UTF-16 for maximum compatibility across Windows versions and perform algorithmic translation with UTF-8 if necessary.</span></span> <span data-ttu-id="58b4c-161">主控台系統正在增加對 UTF-8 的支援。</span><span class="sxs-lookup"><span data-stu-id="58b4c-161">Increased support of UTF-8 is in progress for the console system.</span></span>

<span data-ttu-id="58b4c-162">主控台中的 UTF-16 支援可透過所有主控台 Api 的 _W_ 變體來利用，而不需要額外的設定，而且對於已精通在 utf-16 中的應用程式而言，是更有可能的選擇，因為它會與 `wchar_t` 其他 Microsoft 和 Windows 平臺功能和產品的和 _W_ 變體進行通訊。</span><span class="sxs-lookup"><span data-stu-id="58b4c-162">UTF-16 support in the console can be utilized with no additional configuration via the _W_ variant of all console APIs and is a more likely choice for applications already well versed in UTF-16 through communication with the `wchar_t` and _W_ variant of other Microsoft and Windows platform functions and products.</span></span>

<span data-ttu-id="58b4c-163">您可以視情況將字碼頁設定為 _A_ `65001` 或 `CP_UTF8` [**SetConsoleOutputCP**](setconsoleoutputcp.md)和 [**SetConsoleCP**](setconsolecp.md)方法之後，在主控台控制碼上利用主控台 api 的 utf-8 支援。</span><span class="sxs-lookup"><span data-stu-id="58b4c-163">UTF-8 support in the console can be utilized via the _A_ variant of Console APIs against console handles after setting the codepage to `65001` or `CP_UTF8` with the [**SetConsoleOutputCP**](setconsoleoutputcp.md) and [**SetConsoleCP**](setconsolecp.md) methods, as appropriate.</span></span> <span data-ttu-id="58b4c-164">只有當電腦尚未在主控台的 [區域] 區段中，針對非 Unicode 應用程式的設定選擇 [使用 Unicode UTF-8 來提供全球語言支援] 時，才需要預先設定字碼頁。</span><span class="sxs-lookup"><span data-stu-id="58b4c-164">Setting the code pages in advance is only necessary if the machine has not chosen "Use Unicode UTF-8 for worldwide language support" in the settings for Non-Unicode applications in the Region section of the Control Panel.</span></span>

>[!NOTE]
> <span data-ttu-id="58b4c-165">目前，在標準輸出資料流程上，使用 [**WriteConsole**](writeconsole.md) 和 [**WRITEFILE**](https://msdn.microsoft.com/library/windows/desktop/aa365747) 方法的 utf-8 完全受到支援。</span><span class="sxs-lookup"><span data-stu-id="58b4c-165">As of now, UTF-8 is supported fully on the standard output stream with the [**WriteConsole**](writeconsole.md) and [**WriteFile**](https://msdn.microsoft.com/library/windows/desktop/aa365747) methods.</span></span> <span data-ttu-id="58b4c-166">輸入資料流程的支援會因輸入模式而異，而且會隨著時間持續改善。</span><span class="sxs-lookup"><span data-stu-id="58b4c-166">Support on the input stream varies depending on the input mode and will continue to improve over time.</span></span> <span data-ttu-id="58b4c-167">值得注意的是，輸入的預設「 **[處理後](high-level-console-modes.md)** 」模式並不完全支援 utf-8。</span><span class="sxs-lookup"><span data-stu-id="58b4c-167">Notably the default **["cooked"](high-level-console-modes.md)** modes on input do not fully support UTF-8 yet.</span></span> <span data-ttu-id="58b4c-168">您可以在 GitHub 上的 [**microsoft/terminal # 7777**](https://github.com/microsoft/terminal/issues/7777) 找到此工作的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="58b4c-168">The current status of this work can be found at [**microsoft/terminal#7777**](https://github.com/microsoft/terminal/issues/7777) on GitHub.</span></span> <span data-ttu-id="58b4c-169">解決方法是使用演算法可翻譯的 UTF-16，透過 [**ReadConsoleW**](readconsole.md) 或 [**ReadConsoleInputW**](readconsoleinput.md) 讀取輸入，直到未解決的問題解決為止。</span><span class="sxs-lookup"><span data-stu-id="58b4c-169">The workaround is to use the algorithmically-translatable UTF-16 for reading input through [**ReadConsoleW**](readconsole.md) or [**ReadConsoleInputW**](readconsoleinput.md) until the outstanding issues are resolved.</span></span>

## <a name="recommendations"></a><span data-ttu-id="58b4c-170">建議</span><span class="sxs-lookup"><span data-stu-id="58b4c-170">Recommendations</span></span>

<span data-ttu-id="58b4c-171">針對 Windows 上的所有新開發和持續進行中的開發， **建議將虛擬終端機序列** 作為與終端機互動的方式。</span><span class="sxs-lookup"><span data-stu-id="58b4c-171">For all new and ongoing development on Windows, **virtual terminal sequences are recommended** as the way of interacting with the terminal.</span></span> <span data-ttu-id="58b4c-172">這會將 Windows 命令列用戶端應用程式與所有其他平臺上的應用程式設計樣式融合在一起。</span><span class="sxs-lookup"><span data-stu-id="58b4c-172">This will converge Windows command-line client applications with the style of application programming on all other platforms.</span></span>

### <a name="exceptions-for-using-windows-console-apis"></a><span data-ttu-id="58b4c-173">使用 Windows 主控台 Api 的例外狀況</span><span class="sxs-lookup"><span data-stu-id="58b4c-173">Exceptions for using Windows Console APIs</span></span>

<span data-ttu-id="58b4c-174">建立初始環境 **仍需要有限的 Windows 主控台 api 子集** 。</span><span class="sxs-lookup"><span data-stu-id="58b4c-174">A **limited subset of Windows Console APIs is still necessary** to establish the initial environment.</span></span> <span data-ttu-id="58b4c-175">Windows 平臺在處理、信號、裝置及編碼處理方面仍有不同之處：</span><span class="sxs-lookup"><span data-stu-id="58b4c-175">The Windows platform still differs from others in process, signal, device, and encoding handling:</span></span>

- <span data-ttu-id="58b4c-176">進程的標準控制碼仍會使用 **[GetStdHandle](getstdhandle.md)** 和 **[SetStdHandle](setstdhandle.md)** 來控制。</span><span class="sxs-lookup"><span data-stu-id="58b4c-176">The standard handles to a process will still be controlled with **[GetStdHandle](getstdhandle.md)** and **[SetStdHandle](setstdhandle.md)** .</span></span>

- <span data-ttu-id="58b4c-177">在加入宣告虛擬終端機序列支援的控制碼上設定主控台模式時，將會使用 **[GetConsoleMode](getconsolemode.md)** 和 **[SetConsoleMode](setconsolemode.md)** 來處理。</span><span class="sxs-lookup"><span data-stu-id="58b4c-177">Configuration of the console modes on a handle to opt in to Virtual Terminal Sequence support will be handled with **[GetConsoleMode](getconsolemode.md)** and **[SetConsoleMode](setconsolemode.md)** .</span></span>

- <span data-ttu-id="58b4c-178">程式字碼頁或 UTF-8 支援的宣告會使用 [**SetConsoleOutputCP**](setconsoleoutputcp.md) 和 [**SetConsoleCP**](setconsolecp.md) 方法進行。</span><span class="sxs-lookup"><span data-stu-id="58b4c-178">Declaration of code page or UTF-8 support is conducted with [**SetConsoleOutputCP**](setconsoleoutputcp.md) and [**SetConsoleCP**](setconsolecp.md) methods.</span></span>

- <span data-ttu-id="58b4c-179">[**AllocConsole**](allocconsole.md)、 [**AttachConsole**](attachconsole.md)和 [**FreeConsole**](freeconsole.md)可能需要某種程度的整體進程管理，才能加入或離開主控台裝置會話。</span><span class="sxs-lookup"><span data-stu-id="58b4c-179">Some level of overall process management may be required with the [**AllocConsole**](allocconsole.md), [**AttachConsole**](attachconsole.md) and [**FreeConsole**](freeconsole.md) to join or leave a console device session.</span></span>

- <span data-ttu-id="58b4c-180">使用 [**SetConsoleCtrlHandler**](setconsolectrlhandler.md)、 [**HandlerRoutine**](handlerroutine.md)和 [**GenerateConsoleCtrlEvent**](generateconsolectrlevent.md)時，會繼續進行信號和信號處理。</span><span class="sxs-lookup"><span data-stu-id="58b4c-180">Signals and signal handling will continue to be conducted with [**SetConsoleCtrlHandler**](setconsolectrlhandler.md), [**HandlerRoutine**](handlerroutine.md), and [**GenerateConsoleCtrlEvent**](generateconsolectrlevent.md).</span></span>

- <span data-ttu-id="58b4c-181">您可以使用 [**WriteConsole**](writeconsole.md) 和 [**ReadConsole**](readconsole.md)來執行與主控台裝置控制碼的通訊。</span><span class="sxs-lookup"><span data-stu-id="58b4c-181">Communication with the console device handles can be conducted with [**WriteConsole**](writeconsole.md) and [**ReadConsole**](readconsole.md).</span></span> <span data-ttu-id="58b4c-182">您也可以透過程式設計語言執行時間，利用：-C 執行時間 (CRT) ： [資料流程 i/o](https://docs.microsoft.com/cpp/c-runtime-library/stream-i-o) （例如 **printf** 、 **scanf** 、 **putc** 、 **getc** 或 [其他層級的 i/o 函數](https://docs.microsoft.com/cpp/c-runtime-library/input-and-output)）來利用這些程式設計語言執行時間。</span><span class="sxs-lookup"><span data-stu-id="58b4c-182">These may also be leveraged through programming language runtimes in the forms of: - C Runtime (CRT): [Stream I/O](https://docs.microsoft.com/cpp/c-runtime-library/stream-i-o) like **printf** , **scanf** , **putc** , **getc** , or [other levels of I/O functions](https://docs.microsoft.com/cpp/c-runtime-library/input-and-output).</span></span>
        <span data-ttu-id="58b4c-183">-C + + 標準程式庫 (STL) ： [iostream](https://docs.microsoft.com/cpp/standard-library/iostream) ，例如 **cout** 和 **cin** 。</span><span class="sxs-lookup"><span data-stu-id="58b4c-183">- C++ Standard Library (STL): [iostream](https://docs.microsoft.com/cpp/standard-library/iostream) like **cout** and **cin** .</span></span>
        <span data-ttu-id="58b4c-184">-.NET 執行時間： Console 等 [系統主控台](https://docs.microsoft.com/dotnet/api/system.console) **。**</span><span class="sxs-lookup"><span data-stu-id="58b4c-184">- .NET Runtime: [System.Console](https://docs.microsoft.com/dotnet/api/system.console) like **Console.WriteLine** .</span></span>

- <span data-ttu-id="58b4c-185">必須留意視窗大小變更的應用程式仍然需要使用 [**ReadConsoleInput**](readconsoleinput.md) 來接收它們交錯的金鑰事件，因為 **ReadConsole** 單獨會捨棄它們。</span><span class="sxs-lookup"><span data-stu-id="58b4c-185">Applications that must be aware of window size changes will still need to use [**ReadConsoleInput**](readconsoleinput.md) to receive them interleaved with key events as **ReadConsole** alone will discard them.</span></span>

- <span data-ttu-id="58b4c-186">如果應用程式嘗試繪製資料行、格線或填滿顯示，則仍必須使用 [**GetConsoleScreenBufferInfo**](getconsolescreenbufferinfo.md) 來尋找視窗大小。</span><span class="sxs-lookup"><span data-stu-id="58b4c-186">Finding the window size must still be performed with [**GetConsoleScreenBufferInfo**](getconsolescreenbufferinfo.md) for applications attempting to draw columns, grids, or fill the display.</span></span> <span data-ttu-id="58b4c-187">[Pseudoconsole](pseudoconsoles.md)會話中的視窗和緩衝區大小將會相符。</span><span class="sxs-lookup"><span data-stu-id="58b4c-187">Window and buffer size will match in a [pseudoconsole](pseudoconsoles.md) session.</span></span>

## <a name="future-planning-and-pseudoconsole"></a><span data-ttu-id="58b4c-188">未來規劃和 pseudoconsole</span><span class="sxs-lookup"><span data-stu-id="58b4c-188">Future planning and pseudoconsole</span></span>

<span data-ttu-id="58b4c-189">沒有計劃從平臺移除 Windows 主控台 Api。</span><span class="sxs-lookup"><span data-stu-id="58b4c-189">There are no plans to remove the Windows console APIs from the platform.</span></span>

<span data-ttu-id="58b4c-190">相反地，Windows 主控台主機提供了 **[pseudoconsole](pseudoconsoles.md)** 技術，可將現有的 Windows 命令列應用程式呼叫轉譯為虛擬終端機序列，並將其從遠端或跨平臺轉送到另一個裝載環境。</span><span class="sxs-lookup"><span data-stu-id="58b4c-190">On the contrary, the Windows Console host has provided the **[pseudoconsole](pseudoconsoles.md)** technology to translate existing Windows command-line application calls into virtual terminal sequences and forward them to another hosting environment remotely or across platforms.</span></span>

<span data-ttu-id="58b4c-191">這項轉譯並不完美。</span><span class="sxs-lookup"><span data-stu-id="58b4c-191">This translation is not perfect.</span></span> <span data-ttu-id="58b4c-192">它需要主控台主機視窗，以維護 Windows 對使用者顯示的模擬環境。</span><span class="sxs-lookup"><span data-stu-id="58b4c-192">It requires the console host window to maintain a simulated environment of what Windows would have displayed to the user.</span></span> <span data-ttu-id="58b4c-193">然後，它會將此模擬環境的複本投射至 **pseudoconsole** 主機。</span><span class="sxs-lookup"><span data-stu-id="58b4c-193">It then projects a replica of this simulated environment to the **pseudoconsole** host.</span></span> <span data-ttu-id="58b4c-194">所有 Windows 主控台 API 呼叫都是在模擬環境內運作，以滿足舊版命令列用戶端應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="58b4c-194">All Windows Console API calls are operated within the simulated environment to serve the needs of the legacy command-line client application.</span></span> <span data-ttu-id="58b4c-195">只有效果會傳播到最終的主機上。</span><span class="sxs-lookup"><span data-stu-id="58b4c-195">Only the effects are propagated onto the final host.</span></span>

<span data-ttu-id="58b4c-196">因此，命令列應用程式會 desiring 跨平臺的完整相容性，以及在 Windows 和其他地方完全支援所有新功能和案例，因此建議移至虛擬終端機序列，並調整命令列應用程式的架構，以配合所有平臺。</span><span class="sxs-lookup"><span data-stu-id="58b4c-196">A command-line application desiring full compatibility across platforms and full support of all new features and scenarios both on Windows and elsewhere is therefore recommended to move to virtual terminal sequences and adjust the architecture of command-line applications to align with all platforms.</span></span>

<span data-ttu-id="58b4c-197">有關命令列應用程式之 Windows 轉換的詳細資訊，可以在我們的 [生態系統藍圖](ecosystem-roadmap.md)中找到。</span><span class="sxs-lookup"><span data-stu-id="58b4c-197">More information about this Windows transition for command-line applications can be found on our [ecosystem roadmap](ecosystem-roadmap.md).</span></span>
