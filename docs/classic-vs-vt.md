---
title: 傳統主控台 API 與虛擬終端機順序
description: 說明傳統 Win32 主控台 API 介面與虛擬終端機序列 (有時也稱為逸出序列) 概念之間的對比，以撰寫命令列應用程式。
author: miniksa
ms.author: miniksa
ms.topic: conceptual
keywords: 主控台, 終端機, 虛擬終端機, 逸出序列, vt, vt100, 主控台 api
ms.prod: console
ms.localizationpriority: high
ms.openlocfilehash: 541300b50521909b22ceaccb595f1945fbfc7e6d
ms.sourcegitcommit: 508e93bc83b4bca6ce678f88ab081d66b95d605c
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/04/2020
ms.locfileid: "96420177"
---
# <a name="classic-console-apis-versus-virtual-terminal-sequences"></a><span data-ttu-id="84dd4-104">傳統主控台 API 與虛擬終端機順序</span><span class="sxs-lookup"><span data-stu-id="84dd4-104">Classic Console APIs versus Virtual Terminal Sequences</span></span>

<span data-ttu-id="84dd4-105">我們建議是以 **虛擬終端機序列** 取代傳統 **Windows 主控台 API**。</span><span class="sxs-lookup"><span data-stu-id="84dd4-105">Our recommendation is to replace the classic **Windows Console API** with **virtual terminal sequences**.</span></span> <span data-ttu-id="84dd4-106">本文將概述這兩者之間的差異，並討論我們建議的原因。</span><span class="sxs-lookup"><span data-stu-id="84dd4-106">This article will outline the difference between the two and discuss the reasons for our recommendation.</span></span>

## <a name="definitions"></a><span data-ttu-id="84dd4-107">定義</span><span class="sxs-lookup"><span data-stu-id="84dd4-107">Definitions</span></span>

<span data-ttu-id="84dd4-108">傳統 **[Windows 主控台 API](console-functions.md)** 介面已定義為 `kernel32.dll` 中的 C 語言功能介面系列，其名稱包含 "Console"。</span><span class="sxs-lookup"><span data-stu-id="84dd4-108">The classic **[Windows Console API](console-functions.md)** surface is defined as the series of C language functional interfaces on `kernel32.dll` with "Console" in the name.</span></span>

<span data-ttu-id="84dd4-109">**[虛擬終端機序列](console-virtual-terminal-sequences.md)** 已定義為內嵌在標準輸入和標準輸出資料流中的命令語言。</span><span class="sxs-lookup"><span data-stu-id="84dd4-109">**[Virtual terminal sequences](console-virtual-terminal-sequences.md)** is defined as a language of commands that's embedded in the standard input and standard output streams.</span></span> <span data-ttu-id="84dd4-110">虛擬終端機序列會使用不可列印的逸出字元，對與一般可列印文字交錯的命令進行訊號處理。</span><span class="sxs-lookup"><span data-stu-id="84dd4-110">Virtual terminal sequences use non-printable escape characters for signaling commands interleaved with normal printable text.</span></span>

## <a name="history"></a><span data-ttu-id="84dd4-111">歷程記錄</span><span class="sxs-lookup"><span data-stu-id="84dd4-111">History</span></span>

<span data-ttu-id="84dd4-112">**Windows 主控台** 提供廣泛的 API 介面，以供用戶端命令列應用程式控管輸出顯示緩衝區和使用者輸入緩衝區。</span><span class="sxs-lookup"><span data-stu-id="84dd4-112">The **Windows Console** provides a broad API surface for client command-line applications to manipulate both the output display buffer and the user input buffer.</span></span> <span data-ttu-id="84dd4-113">不過，其他非 Windows 平台從未對其命令列環境提供此種特定 API 驅動方法，而選擇改為使用內嵌在標準輸入和標準輸出資料流中的虛擬終端機序列。</span><span class="sxs-lookup"><span data-stu-id="84dd4-113">However, other non-Windows platforms have never afforded this specific API-driven approach to their command-line environments, choosing instead to use virtual terminal sequences embedded within the standard input and standard output streams.</span></span> <span data-ttu-id="84dd4-114">*(曾有一段時間，Microsoft 透過稱為 ANSI.SYS 的驅動程式，在舊版 DOS 和 Windows 中支援此行為。)*</span><span class="sxs-lookup"><span data-stu-id="84dd4-114">*(For a time, Microsoft supported this behavior too in early editions of DOS and Windows through a driver called ANSI.SYS.)*</span></span>

<span data-ttu-id="84dd4-115">相反地，**虛擬終端機序列** (採用各種方言) 會驅動所有其他平台的命令列環境作業。</span><span class="sxs-lookup"><span data-stu-id="84dd4-115">By contrast, **virtual terminal sequences** (in a variety of dialects) drive the command-line environment operations for  all other platforms.</span></span> <span data-ttu-id="84dd4-116">這些序列是由多家廠商植入 [ECMA 標準](https://www.ecma-international.org/publications/standards/Ecma-048.htm)和擴充功能系列中，可往回追溯至 Digital Equipment Corporation 和 Tektronix 終端機，一直到更現代化和常見的軟體終端機，例如 [xterm](https://invisible-island.net/xterm/)。</span><span class="sxs-lookup"><span data-stu-id="84dd4-116">These sequences are rooted in an [ECMA Standard](https://www.ecma-international.org/publications/standards/Ecma-048.htm) and series of extensions by many vendors tracing back to Digital Equipment Corporation and Tektronix terminals, through to more modern and common software terminals, like [xterm](https://invisible-island.net/xterm/).</span></span> <span data-ttu-id="84dd4-117">虛擬終端機序列網域內有許多擴充功能存在，而且有些序列比其他序列受到更廣泛的支援，但請放心，世界已將此標準化為命令列體驗的命令語言，而且幾乎每個終端機和命令列用戶端應用程式都支援已知的子集。</span><span class="sxs-lookup"><span data-stu-id="84dd4-117">Many extensions exist within the virtual terminal sequence domain and some sequences are more widely supported than others, but it is safe to say that the world has standardized on this as the command language for command-line experiences with a well-known subset being supported by virtually every terminal and command-line client application.</span></span>

## <a name="cross-platform-support"></a><span data-ttu-id="84dd4-118">跨平台支援</span><span class="sxs-lookup"><span data-stu-id="84dd4-118">Cross-Platform Support</span></span>

<span data-ttu-id="84dd4-119">**虛擬終端機序列** 會以原生方式跨平台支援，讓終端機應用程式和命令列公用程式能輕鬆地在不同的作業系統 (Windows 除外) 版本之間進行移植。</span><span class="sxs-lookup"><span data-stu-id="84dd4-119">**Virtual terminal sequences** are natively supported across platforms, making terminal applications and command-line utilities easily portable between versions and variations of operating systems, with the exception of Windows.</span></span>

<span data-ttu-id="84dd4-120">相反地，只有 Windows 支援 **Windows 主控台 API**。</span><span class="sxs-lookup"><span data-stu-id="84dd4-120">By contrast, **Windows Console APIs** are only supported on Windows.</span></span> <span data-ttu-id="84dd4-121">當您嘗試從在平台之間移植命令列公用程式時，必須在 Windows 與虛擬終端機之間撰寫廣大配接器或轉譯程式庫，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="84dd4-121">An extensive adapter or translation library must be written between Windows and virtual terminal, or vice-versa, when attempting to port command-line utilities from one platform or another.</span></span>

### <a name="remote-access"></a><span data-ttu-id="84dd4-122">遠端存取</span><span class="sxs-lookup"><span data-stu-id="84dd4-122">Remote Access</span></span>

<span data-ttu-id="84dd4-123">**虛擬終端機序列** 保有遠端存取的主要優點。</span><span class="sxs-lookup"><span data-stu-id="84dd4-123">**Virtual terminal sequences** hold a major advantage for remote access.</span></span> <span data-ttu-id="84dd4-124">其不需執行額外的工作來傳輸或執行遠端程序呼叫，而是透過設定標準遠端命令列連線所需的功能。</span><span class="sxs-lookup"><span data-stu-id="84dd4-124">They require no additional work to transport, or perform remote procedure calls, over what is required to set up a standard remote command-line connection.</span></span> <span data-ttu-id="84dd4-125">只要透過管道、通訊端、檔案、序列埠或任何其他裝置連接輸出和輸入傳輸通道 (或單一雙向通道)，就足以將應用程式陳述這些序列所需的所有資訊完全送到遠端主機。</span><span class="sxs-lookup"><span data-stu-id="84dd4-125">Simply connecting an outbound and an inbound transport channel (or a single bidirectional channel) over a pipe, socket, file, serial port, or any other device is sufficient to completely carry all information required for an application speaking these sequences to a remote host.</span></span>

<span data-ttu-id="84dd4-126">相反地，**Windows 主控台 API** 只有在本機電腦上可供存取，而在遠端進行的所有工作都需要建立整個遠端呼叫和傳輸介面層，不只是簡單的通道。</span><span class="sxs-lookup"><span data-stu-id="84dd4-126">On the contrary, the **Windows Console APIs** have only been accessible on the local machine and all efforts to remote them would require building an entire remote calling and transport interface layer beyond just a simple channel.</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="84dd4-127">關注點分離</span><span class="sxs-lookup"><span data-stu-id="84dd4-127">Separation of Concerns</span></span>

<span data-ttu-id="84dd4-128">有些 **Windows 主控台 API** 會提供對輸入和輸出緩衝區的低層級存取，或適用於互動式命令列的便捷功能。</span><span class="sxs-lookup"><span data-stu-id="84dd4-128">Some **Windows Console APIs** provide low-level access to the input and output buffers or convenience functions for interactive command-lines.</span></span> <span data-ttu-id="84dd4-129">這可能包括在主控台子系統和主機環境中以程式設計方式撰寫的別名和命令歷程記錄，而不是在命令列用戶端應用程式本身內撰寫。</span><span class="sxs-lookup"><span data-stu-id="84dd4-129">This might include aliases and command history programmed within the console subsystem and host environment, instead of within the command-line client application itself.</span></span>

<span data-ttu-id="84dd4-130">相反地，**其他平台** 讓記住應用程式和便利功能的目前狀態成為命令列公用程式或 Shell 本身的責任。</span><span class="sxs-lookup"><span data-stu-id="84dd4-130">By contrast, **other platforms** make memory of the current state of the application and convenience functionality the responsibility of the command-line utility or shell itself.</span></span>

<span data-ttu-id="84dd4-131">**Windows 主控台** 在主控台主機和 API 中處理這項責任的方式，可讓您更快速且更輕鬆地使用這些功能來撰寫命令列應用程式，進而消除記得描繪狀態或處理編輯便利功能的責任。</span><span class="sxs-lookup"><span data-stu-id="84dd4-131">The **Windows Console** way of handling this responsibility in the console host and API makes it quicker and easier to write a command-line application with these features, removing the responsibility of remembering drawing state or handling editing convenience features.</span></span> <span data-ttu-id="84dd4-132">不過，由於實作和可用性方面的變化，這讓您幾乎無法在不同平台、版本或案例中，從遠端連線這些活動。</span><span class="sxs-lookup"><span data-stu-id="84dd4-132">However, this makes it nearly impossible to connect those activities remotely across platforms, versions, or scenarios due to variations in implementations and availability.</span></span> <span data-ttu-id="84dd4-133">這種處理責任的方式也會讓這些 Windows 命令列應用程式的最終互動式體驗完全相依於主控台主機的實作、優先順序和發行週期。</span><span class="sxs-lookup"><span data-stu-id="84dd4-133">This way of handling responsibility also makes the final interactive experience of these Windows command-line applications completely dependent on the console host's implementation, priorities, and release cycle.</span></span>

<span data-ttu-id="84dd4-134">例如，只有在命令列應用程式處理編輯顧慮本身時，才可以使用進階行編輯功能，例如語法醒目提示和複雜的選取。</span><span class="sxs-lookup"><span data-stu-id="84dd4-134">For example, advanced line editing features, like syntax highlighting and complex selection, are only possible when a command-line application handles editing concerns itself.</span></span> <span data-ttu-id="84dd4-135">主控台絕對無法像用戶端應用程式一樣，以概括的方式完全理解這些案例。</span><span class="sxs-lookup"><span data-stu-id="84dd4-135">The console could never have enough context to fully understand these scenarios in a broad manner like the client application can.</span></span>

<span data-ttu-id="84dd4-136">相反地，其他平台會使用 **虛擬終端機序列**，透過可重複使用的用戶端程式庫 (例如 [readline](https://tiswww.case.edu/php/chet/readline/rltop.html) 和 [ncurses](https://invisible-island.net/ncurses/ncurses.html)) 來處理這些活動和虛擬終端機通訊本身。</span><span class="sxs-lookup"><span data-stu-id="84dd4-136">By contrast, other platforms use **virtual terminal sequences** to handle these activities and virtual terminal communication itself through reusable client-side libraries, like [readline](https://tiswww.case.edu/php/chet/readline/rltop.html) and [ncurses](https://invisible-island.net/ncurses/ncurses.html).</span></span> <span data-ttu-id="84dd4-137">最終終端機只負責顯示資訊和透過該雙向通道接收輸入。</span><span class="sxs-lookup"><span data-stu-id="84dd4-137">The final terminal is only responsible for displaying information and receiving input through that bidirectional communication channel.</span></span>

### <a name="wrong-way-verbs"></a><span data-ttu-id="84dd4-138">錯誤的動詞命令</span><span class="sxs-lookup"><span data-stu-id="84dd4-138">Wrong-Way Verbs</span></span>

<span data-ttu-id="84dd4-139">透過 **Windows 主控台**，可以在輸入和輸出資料流上，以反自然的方向執行某些動作。</span><span class="sxs-lookup"><span data-stu-id="84dd4-139">With **Windows Console**, some actions can be performed in the opposite-to-natural direction on the input and output streams.</span></span> <span data-ttu-id="84dd4-140">這可讓 Windows 命令列應用程式避免管理自有緩衝區的疑慮。</span><span class="sxs-lookup"><span data-stu-id="84dd4-140">This allows Windows command-line applications to avoid the concern of managing their own buffers.</span></span> <span data-ttu-id="84dd4-141">也可讓 Windows 命令列應用程式執行進階作業，例如，代表使用者模擬/插入輸入，或讀回已寫入的部分歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="84dd4-141">It also allows Windows command-line apps to perform advanced operations, like simulating/injecting input on behalf of a user, or reading back some of the history of what was written.</span></span>

<span data-ttu-id="84dd4-142">雖然這可讓 Windows 應用程式在單一電腦上的特定使用者內容中運作，但是若使用於某些案例，也會提供一個媒介來跨越安全性和權限層級或網域。</span><span class="sxs-lookup"><span data-stu-id="84dd4-142">While this provides additional power to Windows applications operating in a specific user-context on a single machine, it also provides a vector to cross security and privilege-levels or domains when used in certain scenarios.</span></span> <span data-ttu-id="84dd4-143">這類案例包括在同一部電腦上的不同內容之間運作，或是將內容跨越至另一個電腦或環境。</span><span class="sxs-lookup"><span data-stu-id="84dd4-143">Such scenarios include operating between contexts on the same machine, or across contexts to another machine or environment.</span></span>

<span data-ttu-id="84dd4-144">其他使用 **虛擬終端機序列** 的平台則不允許此活動。</span><span class="sxs-lookup"><span data-stu-id="84dd4-144">Other platforms, which use **virtual terminal sequences**, do not allow this activity.</span></span> <span data-ttu-id="84dd4-145">我們建議從傳統 Windows 主控台轉換到虛擬終端機序列的意圖，就是基於互通性和安全性理由來趨近此策略。</span><span class="sxs-lookup"><span data-stu-id="84dd4-145">The intent of our recommendation to transition from classic Windows Console to virtual terminal sequences is to converge with this strategy for both interoperability and security reasons.</span></span>

### <a name="direct-window-access"></a><span data-ttu-id="84dd4-146">直接視窗存取</span><span class="sxs-lookup"><span data-stu-id="84dd4-146">Direct Window Access</span></span>

<span data-ttu-id="84dd4-147">**Windows 主控台 API 介面** 會提供主控視窗的精確視窗控點。</span><span class="sxs-lookup"><span data-stu-id="84dd4-147">**Windows Console API surface** provides the exact window handle to the hosting window.</span></span> <span data-ttu-id="84dd4-148">這可讓命令列公用程式藉由進入針對視窗控點所允許的各種 Win32 API 來執行進階視窗作業。</span><span class="sxs-lookup"><span data-stu-id="84dd4-148">This allows a command-line utility to perform advanced window operations by reaching into the wide gamut of Win32 APIs permitted against a window handle.</span></span> <span data-ttu-id="84dd4-149">這些 Win32 API 可以控管視窗狀態、框架、圖示或視窗的其他相關屬性。</span><span class="sxs-lookup"><span data-stu-id="84dd4-149">These Win32 APIs can manipulate the window state, frame, icon, or other properties about the window.</span></span>

<span data-ttu-id="84dd4-150">相反地，在具有 **虛擬終端機序列** 的其他平台上，有一小組可針對視窗執行的命令。</span><span class="sxs-lookup"><span data-stu-id="84dd4-150">By contrast, on other platforms with **virtual terminal sequences**, there is a narrow set of commands that can be performed against the window.</span></span> <span data-ttu-id="84dd4-151">這些命令可執行像是變更視窗大小或所顯示標題之類的作業，但必須在相同的頻帶中以及與資料流其餘部分相同的控制下完成。</span><span class="sxs-lookup"><span data-stu-id="84dd4-151">These commands can do things like changing the window size or displayed title, but they must be done in the same band and under the same control as the remainder of the stream.</span></span>

<span data-ttu-id="84dd4-152">隨著 Windows 演變，視窗控點的安全性控制和限制也隨之增加。</span><span class="sxs-lookup"><span data-stu-id="84dd4-152">As Windows has evolved, the security controls and restrictions on window handles have increased.</span></span> <span data-ttu-id="84dd4-153">此外，在任何特定使用者介面元素上，應用程式可定址視窗控點的性質和存在已演進，尤其是對裝置外型規格和平台的支援增加。</span><span class="sxs-lookup"><span data-stu-id="84dd4-153">Additionally, the nature and existence of an application-addressable window handle on any specific user interface element has evolved, especially with the increased support of device form factors and platforms.</span></span> <span data-ttu-id="84dd4-154">這可讓命令列應用程式的直接視窗存取變得脆弱，因為平台和體驗都進化。</span><span class="sxs-lookup"><span data-stu-id="84dd4-154">This makes direct window access to command-line applications fragile as the platform and experiences evolve.</span></span>

### <a name="unicode"></a><span data-ttu-id="84dd4-155">Unicode</span><span class="sxs-lookup"><span data-stu-id="84dd4-155">Unicode</span></span>

<span data-ttu-id="84dd4-156">UTF-8 是幾乎所有新式平台上 Unicode 資料接受的編碼，因為其在可攜性、儲存體大小和處理時間之間達到適當的平衡。</span><span class="sxs-lookup"><span data-stu-id="84dd4-156">UTF-8 is the accepted encoding for Unicode data across almost all modern platforms, as it strikes the right balance between portability, storage size and processing time.</span></span> <span data-ttu-id="84dd4-157">不過，Windows 在過去選擇 UTF-16 作為 Unicode 資料的主要編碼。</span><span class="sxs-lookup"><span data-stu-id="84dd4-157">However, Windows historically chose UTF-16 as its primary encoding for Unicode data.</span></span> <span data-ttu-id="84dd4-158">Windows 中的 UTF-8 支援一直增加，使用這些 Unicode 格式並不會妨礙其他編碼的使用。</span><span class="sxs-lookup"><span data-stu-id="84dd4-158">Support for UTF-8 is increasing in Windows and use of these Unicode formats does not preclude the usage of other encodings.</span></span>

<span data-ttu-id="84dd4-159">**Windows 主控台** 平台已支援並將持續支援所有現有的字碼頁和編碼。</span><span class="sxs-lookup"><span data-stu-id="84dd4-159">The **Windows Console** platform has supported and will continue to support all existing code pages and encodings.</span></span> <span data-ttu-id="84dd4-160">使用 UTF-16 以達到跨 Windows 版本的最大相容性，並在必要時以 UTF-8 執行演算轉譯。</span><span class="sxs-lookup"><span data-stu-id="84dd4-160">Use UTF-16 for maximum compatibility across Windows versions and perform algorithmic translation with UTF-8 if necessary.</span></span> <span data-ttu-id="84dd4-161">主控台系統正在增加 UTF-8 的支援。</span><span class="sxs-lookup"><span data-stu-id="84dd4-161">Increased support of UTF-8 is in progress for the console system.</span></span>

<span data-ttu-id="84dd4-162">不需透過所有主控台 API 的 _W_ 變體來進行其他設定，便可利用主控台中的 UTF-16 支援，而對於透過與其他 Microsoft 和 Windows 平台功能和產品的 `wchar_t` 和 _W_ 變體通訊而已經精通 UTF-16 的應用程式而言，UTF-16 支援是比較合適的選擇。</span><span class="sxs-lookup"><span data-stu-id="84dd4-162">UTF-16 support in the console can be utilized with no additional configuration via the _W_ variant of all console APIs and is a more likely choice for applications already well versed in UTF-16 through communication with the `wchar_t` and _W_ variant of other Microsoft and Windows platform functions and products.</span></span>

<span data-ttu-id="84dd4-163">透過 [**SetConsoleOutputCP**](setconsoleoutputcp.md) 和 [**SetConsoleCP**](setconsolecp.md) 方法將字碼頁設定為 `65001` 或 `CP_UTF8` 之後，即可透過主控台 API 的 _A_ 變體，對主控台控點利用主控台中的 UTF-8 支援。</span><span class="sxs-lookup"><span data-stu-id="84dd4-163">UTF-8 support in the console can be utilized via the _A_ variant of Console APIs against console handles after setting the codepage to `65001` or `CP_UTF8` with the [**SetConsoleOutputCP**](setconsoleoutputcp.md) and [**SetConsoleCP**](setconsolecp.md) methods, as appropriate.</span></span> <span data-ttu-id="84dd4-164">只有在電腦尚未在 [控制台] 的 [地區] 區段中針對非 Unicode 應用程式的設定選擇 [使用 Unicode UTF-8 作為全球語言支援] 時，才需要預先設定字碼頁。</span><span class="sxs-lookup"><span data-stu-id="84dd4-164">Setting the code pages in advance is only necessary if the machine has not chosen "Use Unicode UTF-8 for worldwide language support" in the settings for Non-Unicode applications in the Region section of the Control Panel.</span></span>

>[!NOTE]
> <span data-ttu-id="84dd4-165">從現在開始，透過 [**WriteConsole**](writeconsole.md) 和 [**WriteFile**](https://msdn.microsoft.com/library/windows/desktop/aa365747) 方法在標準輸出資料流上完全支援 UTF-8。</span><span class="sxs-lookup"><span data-stu-id="84dd4-165">As of now, UTF-8 is supported fully on the standard output stream with the [**WriteConsole**](writeconsole.md) and [**WriteFile**](https://msdn.microsoft.com/library/windows/desktop/aa365747) methods.</span></span> <span data-ttu-id="84dd4-166">輸入資料流的支援會隨著輸入模式而有所不同，並且會隨著時間繼續改善。</span><span class="sxs-lookup"><span data-stu-id="84dd4-166">Support on the input stream varies depending on the input mode and will continue to improve over time.</span></span> <span data-ttu-id="84dd4-167">值得注意的是，輸入上的預設 **[「修正」](high-level-console-modes.md)** 模式尚未完全支援 UTF-8。</span><span class="sxs-lookup"><span data-stu-id="84dd4-167">Notably the default **["cooked"](high-level-console-modes.md)** modes on input do not fully support UTF-8 yet.</span></span> <span data-ttu-id="84dd4-168">在 GitHub 上的 [**microsoft/terminal#7777**](https://github.com/microsoft/terminal/issues/7777) 可找到此工作的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="84dd4-168">The current status of this work can be found at [**microsoft/terminal#7777**](https://github.com/microsoft/terminal/issues/7777) on GitHub.</span></span> <span data-ttu-id="84dd4-169">因應措施是使用可以演算法方式轉譯的 UTF-16，透過 [**ReadConsoleW**](readconsole.md) 或 [**ReadConsoleInputW**](readconsoleinput.md) 來讀取輸入，直到解決懸而未決的問題為止。</span><span class="sxs-lookup"><span data-stu-id="84dd4-169">The workaround is to use the algorithmically-translatable UTF-16 for reading input through [**ReadConsoleW**](readconsole.md) or [**ReadConsoleInputW**](readconsoleinput.md) until the outstanding issues are resolved.</span></span>

## <a name="recommendations"></a><span data-ttu-id="84dd4-170">建議</span><span class="sxs-lookup"><span data-stu-id="84dd4-170">Recommendations</span></span>

<span data-ttu-id="84dd4-171">對於在 Windows 上進行的所有全新和持續開發，**建議使用虛擬終端機序列** 作為與終端機互動的方式。</span><span class="sxs-lookup"><span data-stu-id="84dd4-171">For all new and ongoing development on Windows, **virtual terminal sequences are recommended** as the way of interacting with the terminal.</span></span> <span data-ttu-id="84dd4-172">這會將 Windows 命令列用戶端應用程式與其他所有平台上的應用程式設計樣式匯聚在一起。</span><span class="sxs-lookup"><span data-stu-id="84dd4-172">This will converge Windows command-line client applications with the style of application programming on all other platforms.</span></span>

### <a name="exceptions-for-using-windows-console-apis"></a><span data-ttu-id="84dd4-173">使用 Windows 主控台 API 的例外狀況</span><span class="sxs-lookup"><span data-stu-id="84dd4-173">Exceptions for using Windows Console APIs</span></span>

<span data-ttu-id="84dd4-174">建立初始環境時，仍然需要 **有限的 Windows 主控台 API 子集**。</span><span class="sxs-lookup"><span data-stu-id="84dd4-174">A **limited subset of Windows Console APIs is still necessary** to establish the initial environment.</span></span> <span data-ttu-id="84dd4-175">在程序、訊號、裝置和編碼處理方面，Windows 平台仍然與其他平台有所不同：</span><span class="sxs-lookup"><span data-stu-id="84dd4-175">The Windows platform still differs from others in process, signal, device, and encoding handling:</span></span>

- <span data-ttu-id="84dd4-176">程序的標準控點仍會使用 **[GetStdHandle](getstdhandle.md)** 和 **[SetStdHandle](setstdhandle.md)** 進行控制。</span><span class="sxs-lookup"><span data-stu-id="84dd4-176">The standard handles to a process will still be controlled with **[GetStdHandle](getstdhandle.md)** and **[SetStdHandle](setstdhandle.md)**.</span></span>

- <span data-ttu-id="84dd4-177">在要加入虛擬終端機序列支援的控點上，將會使用 **[GetConsoleMode](getconsolemode.md)** 和 **[SetConsoleMode](setconsolemode.md)** 來處理主控台模式的設定。</span><span class="sxs-lookup"><span data-stu-id="84dd4-177">Configuration of the console modes on a handle to opt in to Virtual Terminal Sequence support will be handled with **[GetConsoleMode](getconsolemode.md)** and **[SetConsoleMode](setconsolemode.md)**.</span></span>

- <span data-ttu-id="84dd4-178">字碼頁或 UTF-8 支援的宣告會利用 [**SetConsoleOutputCP**](setconsoleoutputcp.md) 和 [**SetConsoleCP**](setconsolecp.md) 方法進行。</span><span class="sxs-lookup"><span data-stu-id="84dd4-178">Declaration of code page or UTF-8 support is conducted with [**SetConsoleOutputCP**](setconsoleoutputcp.md) and [**SetConsoleCP**](setconsolecp.md) methods.</span></span>

- <span data-ttu-id="84dd4-179">[**AllocConsole**](allocconsole.md)、[**AttachConsole**](attachconsole.md) 和 [**FreeConsole**](freeconsole.md) 可能需要某種程度的整體程序管理，才能加入或離開主控台裝置工作階段。</span><span class="sxs-lookup"><span data-stu-id="84dd4-179">Some level of overall process management may be required with the [**AllocConsole**](allocconsole.md), [**AttachConsole**](attachconsole.md) and [**FreeConsole**](freeconsole.md) to join or leave a console device session.</span></span>

- <span data-ttu-id="84dd4-180">[**SetConsoleCtrlHandler**](setconsolectrlhandler.md)、[**HandlerRoutine**](handlerroutine.md) 和 [**GenerateConsoleCtrlEvent**](generateconsolectrlevent.md) 會繼續進行訊號和訊號處理。</span><span class="sxs-lookup"><span data-stu-id="84dd4-180">Signals and signal handling will continue to be conducted with [**SetConsoleCtrlHandler**](setconsolectrlhandler.md), [**HandlerRoutine**](handlerroutine.md), and [**GenerateConsoleCtrlEvent**](generateconsolectrlevent.md).</span></span>

- <span data-ttu-id="84dd4-181">可以透過 [**WriteConsole**](writeconsole.md) 和 [**ReadConsole**](readconsole.md) 進行與主控台裝置控點的通訊。</span><span class="sxs-lookup"><span data-stu-id="84dd4-181">Communication with the console device handles can be conducted with [**WriteConsole**](writeconsole.md) and [**ReadConsole**](readconsole.md).</span></span> <span data-ttu-id="84dd4-182">也可透過以下形式的程式設計語言執行階段來進行：- C 執行階段 (CRT)：**printf**、**scanf**、**putc**、**getc** 之類的[資料流 I/O](https://docs.microsoft.com/cpp/c-runtime-library/stream-i-o)，或[其他層級的 I/O 函式](https://docs.microsoft.com/cpp/c-runtime-library/input-and-output)。</span><span class="sxs-lookup"><span data-stu-id="84dd4-182">These may also be leveraged through programming language runtimes in the forms of: - C Runtime (CRT): [Stream I/O](https://docs.microsoft.com/cpp/c-runtime-library/stream-i-o) like **printf**, **scanf**, **putc**, **getc**, or [other levels of I/O functions](https://docs.microsoft.com/cpp/c-runtime-library/input-and-output).</span></span>
        <span data-ttu-id="84dd4-183">- C++ 標準程式庫 (STL)：[iostream](https://docs.microsoft.com/cpp/standard-library/iostream)，例如 **cout** 和 **cin**。</span><span class="sxs-lookup"><span data-stu-id="84dd4-183">- C++ Standard Library (STL): [iostream](https://docs.microsoft.com/cpp/standard-library/iostream) like **cout** and **cin**.</span></span>
        <span data-ttu-id="84dd4-184">- .NET 執行階段：[System.Console](https://docs.microsoft.com/dotnet/api/system.console)，例如 **Console.WriteLine**。</span><span class="sxs-lookup"><span data-stu-id="84dd4-184">- .NET Runtime: [System.Console](https://docs.microsoft.com/dotnet/api/system.console) like **Console.WriteLine**.</span></span>

- <span data-ttu-id="84dd4-185">必須留意視窗大小變更的應用程式，仍然需要使用 [**ReadConsoleInput**](readconsoleinput.md) 來接收與重要事件交錯的變更，因為 **ReadConsole** 會獨自捨棄這些變更。</span><span class="sxs-lookup"><span data-stu-id="84dd4-185">Applications that must be aware of window size changes will still need to use [**ReadConsoleInput**](readconsoleinput.md) to receive them interleaved with key events as **ReadConsole** alone will discard them.</span></span>

- <span data-ttu-id="84dd4-186">尋找視窗大小仍必須使用 [**GetConsoleScreenBufferInfo**](getconsolescreenbufferinfo.md) 執行，以便應用程式嘗試描繪資料行、格線或填滿顯示。</span><span class="sxs-lookup"><span data-stu-id="84dd4-186">Finding the window size must still be performed with [**GetConsoleScreenBufferInfo**](getconsolescreenbufferinfo.md) for applications attempting to draw columns, grids, or fill the display.</span></span> <span data-ttu-id="84dd4-187">視窗和緩衝區大小會在 [pseudoconsole](pseudoconsoles.md) 工作階段中比對。</span><span class="sxs-lookup"><span data-stu-id="84dd4-187">Window and buffer size will match in a [pseudoconsole](pseudoconsoles.md) session.</span></span>

## <a name="future-planning-and-pseudoconsole"></a><span data-ttu-id="84dd4-188">未來規劃和 Pseudoconsole</span><span class="sxs-lookup"><span data-stu-id="84dd4-188">Future planning and pseudoconsole</span></span>

<span data-ttu-id="84dd4-189">不打算從平排中移除 Windows 主控台 API。</span><span class="sxs-lookup"><span data-stu-id="84dd4-189">There are no plans to remove the Windows console APIs from the platform.</span></span>

<span data-ttu-id="84dd4-190">相反地，Windows 主控台主機已提供 **[pseudoconsole](pseudoconsoles.md)** 技術，可將現有的 Windows 命令列應用程式呼叫轉譯為虛擬終端機序列，並從遠端或跨越平台將其轉送至另一個主控環境。</span><span class="sxs-lookup"><span data-stu-id="84dd4-190">On the contrary, the Windows Console host has provided the **[pseudoconsole](pseudoconsoles.md)** technology to translate existing Windows command-line application calls into virtual terminal sequences and forward them to another hosting environment remotely or across platforms.</span></span>

<span data-ttu-id="84dd4-191">這種轉譯並不完美。</span><span class="sxs-lookup"><span data-stu-id="84dd4-191">This translation is not perfect.</span></span> <span data-ttu-id="84dd4-192">需要主控台主機視窗，才能維護 Windows 對使用者所顯示的模擬環境。</span><span class="sxs-lookup"><span data-stu-id="84dd4-192">It requires the console host window to maintain a simulated environment of what Windows would have displayed to the user.</span></span> <span data-ttu-id="84dd4-193">接著，將此模擬環境的複本投射到 **pseudoconsole** 主機。</span><span class="sxs-lookup"><span data-stu-id="84dd4-193">It then projects a replica of this simulated environment to the **pseudoconsole** host.</span></span> <span data-ttu-id="84dd4-194">所有 Windows 主控台 API 呼叫都是在模擬環境中運作，以滿足舊版命令列用戶端應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="84dd4-194">All Windows Console API calls are operated within the simulated environment to serve the needs of the legacy command-line client application.</span></span> <span data-ttu-id="84dd4-195">只有效果會傳播到最終主機。</span><span class="sxs-lookup"><span data-stu-id="84dd4-195">Only the effects are propagated onto the final host.</span></span>

<span data-ttu-id="84dd4-196">命令列應用程式很渴望跨平台的完全相容性，以及在 Windows 和其他平台上完整支援所有的新功能和案例，因此建議移至虛擬終端機序列，並調整命令列應用程式的架構以符合所有平台。</span><span class="sxs-lookup"><span data-stu-id="84dd4-196">A command-line application desiring full compatibility across platforms and full support of all new features and scenarios both on Windows and elsewhere is therefore recommended to move to virtual terminal sequences and adjust the architecture of command-line applications to align with all platforms.</span></span>

<span data-ttu-id="84dd4-197">如需命令列應用程式的此種 Windows 轉換詳細資訊，請參閱我們的[生態系統藍圖](ecosystem-roadmap.md)。</span><span class="sxs-lookup"><span data-stu-id="84dd4-197">More information about this Windows transition for command-line applications can be found on our [ecosystem roadmap](ecosystem-roadmap.md).</span></span>
